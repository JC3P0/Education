/*______________________________________
* FILE: HW_04_UNIQUE_(SMART)POINTERS_JC
* AUTHOR: Josh Clemens
* MODULE: 4
* PROJECT: 1
* LAST MODIFIED: September 15, 2022
* PROBLEM STATEMENT: Store 10 stones by randomly selecting a slot till an empty slot is found and all stones are stored.
* ALGORITHM:
*     INITIALIZE Stone structure to include variables to create and track attempts and slots.
*     INITIALIZE variables random, total, attempts, index, storeIndex, letterArray[], uniqure_ptr to stone objects. 
*     LOOP nested for loops to generate a random number to create and store a Stone object into random slot, will loop till a slot is found and all stones are stored.
*     CALCULATE attemtps, total attempts to create and find slot for Stone objects.
*     OUTPUT unipue_ptr array of stone objects created in nested for loops.
*     CALCULATE sort the unipue_ptr array of stone objects by stone Letter A-J.
*     OUTPUT unipue_ptr array of stone objects.
*______________________________________*/

#include <cstdlib>
#include <iostream>
#include <memory>
#include <ctime>

using namespace std;

struct Stone {
    char stoneLetter = ' ';
    int findSlot = 0;
    int originalSlot = 0; //extra credit saves the index of the stored slot
    int storedSlot = 0; //extra credit saves the actual slot stored location, generated by random number
    Stone(char stoneLetter, int findSlot, int originalSlot, int storedSlot){
        this->stoneLetter = stoneLetter;
        this->findSlot = findSlot;
        this->originalSlot = originalSlot;
        this->storedSlot = storedSlot;
    }
};

int main() {

    /***** DECLARATION & INITIALIZATION SECTION *****/

    int random = 0;
    int total = 0;
    srand(time(NULL));

    //used in nested for loop to create Stone objects
    int attempts = 0;
    int index = 0;
    int storeIndex = 0;

    //array to initialize stone letter in for loop with index
    char letterArray[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'};

    //unique pointer to Stone objects
    unique_ptr<Stone>slots[10];

    /***** INTRO SECTION *****/

    cout << "Welcome to the Unique (Smart) Pointers program!\n\n";

    /***** INPUT SECTION *****/
    //no input

    /***** PROCESSING / OUTPUT SECTION *****/

    //nested for loops to store a stone in a random slot, will loop till a slot is found and all stones are stored.
    for(int i = 0; i < 10; i++){ 
        //reset values back to 0 to process for each loop
        attempts = 0;
        index = 0;
        storeIndex = 0;
        for(int j = 0; j < 100; j++){
            //store attempts per stone
            attempts++;
            //find the total attempts of all stones
            total += attempts;
            random = rand() % 10;
            //if the slot is emtpy, the first loop index is stored, the slot is stored then used to create new stone object using unique pointers
            if(!slots[random]){
                index = i;
                storeIndex = random;
                unique_ptr<Stone> new_stone(new Stone(letterArray[i], attempts, index, storeIndex));
                slots[random] = move(new_stone);
                break;
            }
        }
    }

    //output slots[]
    cout << "Slot  Stone  Attempts \n----  -----  --------\n";
    for(int i = 0; i < 10; i++){
        cout << "  " << slots[i]->storedSlot << "     " << slots[i]->stoneLetter << "      " << slots[i]->findSlot << endl;
    }

    //extra credit
    //sort slots[] with originalSlot value
    for(int i = 0; i < 10; i++){
        for(int j = i + 1; j < 10; j++){
            if(slots[j]->originalSlot < slots[i]->originalSlot){
                swap(slots[i], slots[j]);
                // testing line
                // cout << "A swap occured\n";
            }
        }
    }

    //output sorted slots[]
    cout << "\nStone  Slot  Attempts \n-----  ----  --------\n";
    for(int i = 0; i < 10; i++){
        cout << "  "  << slots[i]->stoneLetter << "      " << slots[i]->storedSlot << "      " << slots[i]->findSlot << endl;
    }

    cout << "\nTotal Attempts: " << total;

    // system("PAUSE"); //for DevC++ on windows
    return EXIT_SUCCESS;

}